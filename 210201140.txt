// Uygulama Class


import java.awt.Graphics;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;

import javax.swing.JFrame;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.border.Border;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.JComboBox;
import javax.swing.JTextField;
import javax.swing.UIManager;

public class Uygulama {


    JFrame frame;
    
    //VARIABLES
    private int cells = 24;
    private int delay = 30;

    private int startx = -1;
    private int starty = -1;
    private int finishx = -1;
    private int finishy = -1;
    private int tool = 0;
    private int problemIndex = 0;
    private int steps = 0;
    private int length = 0;

    private int WIDTH = 850;
    private final int HEIGHT = 650;
    private final int MSIZE = 600;
    private int CSIZE = MSIZE / cells;
    private long startTime;
    private long stopTime;
    private String link;
    
    //UTIL ARRAYS

    private String[] problem = {"Problem 1", "Problem 2"};
    //private String[] tools = {"Start", "Finish", "Wall", "Eraser"};
    //BOOLEANS
    private boolean searching = false;
    //UTIL
    Node[][] map;
    //Robot Alg = new Robot();
    Algorithm Alg = new Algorithm();
    Random r = new Random();
    
    //SLIDERS
    JSlider speed = new JSlider(0, 500, delay);

    //LABELS
    JLabel toolL = new JLabel("Problem :");

    JLabel delayL = new JLabel("Delay:");
    JLabel msL = new JLabel(delay + "ms");
    JTextField linkL = new JTextField("URL");

    JLabel stepL = new JLabel("Steps: " + steps);
    JLabel lengthL = new JLabel("Path Length: " + length);
    JLabel TimingL = new JLabel("Elapsed Time: 0");
    
    
    //BUTTONS
    JButton searchB = new JButton("Start Search");
    JButton resetB = new JButton("Reset");
    JButton genMapB = new JButton("Generate Map");
    JButton clearMapB = new JButton("Clear Map");

    JButton LinkChangeB = new JButton("Change Link");


    JComboBox problemBx = new JComboBox(problem);
    //PANELS
    JPanel toolP = new JPanel();
    //CANVAS
    Map canvas;
    
    //BORDER
    Border loweredetched = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED);

    // Main
    public static void main(String[] args) throws Exception {	//MAIN METHOD

        // UIManager.setLookAndFeel("com.jtattoo.plaf.noire.NoireLookAndFeel");        //   10
        //   UIManager.setLookAndFeel("com.jtattoo.plaf.smart.SmartLookAndFeel");        //   11
         UIManager.setLookAndFeel("com.jtattoo.plaf.texture.TextureLookAndFeel");     //  12

        new Uygulama();

    }

    public Uygulama() {	//CONSTRUCTOR
        clearMap(); // if you delete this you will see the GUI when you move the mouse
        initialize();

    }

    public Uygulama(String S) {	//CONSTRUCTOR
        System.out.println("SECOND CONST");

    }

    public void generateMap() {	//GENERATE MAP
        clearMap();	//CREATE CLEAR MAP TO START

        if (problemIndex == 0) {

            link = linkL.getText();

            Izgara izgara = new Izgara(cells, delay, startx, starty, finishx, finishy, tool, steps, length, CSIZE, searching, map);
            StartAndEndPos SAEP = izgara.Waller(problemIndex, link); // Struct Return
            cells = SAEP.getMaze().length;
            clearMap();
            map = SAEP.getMap();

            
            // Select Random Location for start and end
            int k = ThreadLocalRandom.current().nextInt(0, cells);
            int l = ThreadLocalRandom.current().nextInt(0, cells);
            int m = ThreadLocalRandom.current().nextInt(0, cells);
            int n = ThreadLocalRandom.current().nextInt(0, cells);

            if ((k + l) == (m + n)) {
                k = ThreadLocalRandom.current().nextInt(0, cells);
                l = ThreadLocalRandom.current().nextInt(0, cells);
                m = ThreadLocalRandom.current().nextInt(0, cells);
                n = ThreadLocalRandom.current().nextInt(0, cells);
            }

            canvas.StartAndEnd(k, l, m, n);

        }

        if (problemIndex == 1) {

            //
            cells = Integer.parseInt(linkL.getText());
            
            // Blocking Even Cell (Izgara) Number
            if(cells%2 == 0)
            {
                cells++;
            }

            clearMap();
            Izgara izgara = new Izgara(cells, delay, startx, starty, finishx, finishy, tool, steps, length, CSIZE, searching, map);
            StartAndEndPos SAEP = izgara.Waller(problemIndex, null);
            map = SAEP.getMap();
            canvas.StartAndEnd(SAEP.getStartX(), SAEP.getStartY(), SAEP.getEndX(), SAEP.getEndY());

        }

    }

    public void clearMap() {	//CLEAR MAP
        finishx = -1;	//RESET THE START AND FINISH
        finishy = -1;
        startx = -1;
        starty = -1;
        map = new Node[cells][cells];	//CREATE NEW MAP OF NODES
        for (int x = 0; x < cells; x++) {
            for (int y = 0; y < cells; y++) {
                map[x][y] = new Node(3, x, y, finishx, finishy);	//SET ALL NODES TO EMPTY
            }
        }
        reset();	//RESET SOME VARIABLES
    }

    public void resetMap() {	//RESET MAP
        for (int x = 0; x < cells; x++) {
            for (int y = 0; y < cells; y++) {
                Node current = map[x][y];
                if (current.getType() == 4 || current.getType() == 5 || current.getType() == 55) //CHECK TO SEE IF CURRENT NODE IS EITHER CHECKED OR FINAL PATH
                {
                    map[x][y] = new Node(3, x, y, finishx, finishy);	//RESET IT TO AN EMPTY NODE
                }
            }
        }
        if (startx > -1 && starty > -1) {	//RESET THE START AND FINISH
            map[startx][starty] = new Node(0, startx, starty, finishx, finishy);
            map[startx][starty].setHops(0);
        }
        if (finishx > -1 && finishy > -1) {
            map[finishx][finishy] = new Node(1, finishx, finishy, finishx, finishy);
        }
        reset();	//RESET SOME VARIABLES
    }

    private void initialize() {	//INITIALIZE THE GUI ELEMENTS
        frame = new JFrame();
        frame.setVisible(true);
        frame.setResizable(false);
        frame.setSize(WIDTH, HEIGHT);
        frame.setTitle("RobotX");
        frame.setLocationRelativeTo(null);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().setLayout(null);

        toolP.setBorder(BorderFactory.createTitledBorder(loweredetched, "Manage"));
        int extra = 25;
        int temp = 45;

        toolP.setLayout(null);
        toolP.setBounds(10, 10, 210, 600);

        searchB.setBounds(40, extra, 120, 25);
        toolP.add(searchB);
        extra += temp;

        resetB.setBounds(40, extra, 120, 25);
        toolP.add(resetB);
        extra += temp;

        genMapB.setBounds(40, extra, 120, 25);
        toolP.add(genMapB);
        extra += temp;

        clearMapB.setBounds(40, extra, 120, 25);
        toolP.add(clearMapB);
        extra += 40;

        extra += 25;


        toolL.setBounds(40, extra, 120, 25);
        toolP.add(toolL);
        extra += 25;

        problemBx.setBounds(40, extra, 120, 25);
        toolP.add(problemBx);

        TimingL.setBounds(15, extra + 175, 180, 25);
        toolP.add(TimingL);

        linkL.setBounds(15, extra + 145, 180, 25);
        toolP.add(linkL);

        extra += temp;

        extra += temp;

        delayL.setBounds(15, extra - 50, 50, 25);
        toolP.add(delayL);
        speed.setMajorTickSpacing(5);
        speed.setBounds(50, extra - 50, 100, 25);
        toolP.add(speed);
        msL.setBounds(160, extra - 50, 40, 25);
        toolP.add(msL);
        extra += temp;

        LinkChangeB.setBounds(40, extra - 30, 120, 25);
        toolP.add(LinkChangeB);

        extra += temp;

        stepL.setBounds(15, extra + 20, 100, 25);
        toolP.add(stepL);
        extra += temp;

        lengthL.setBounds(15, extra, 100, 25);
        toolP.add(lengthL);
        extra += temp;

        frame.getContentPane().add(toolP);

        canvas = new Map();
        canvas.setBounds(230, 10, MSIZE + 1, MSIZE + 1);
        frame.getContentPane().add(canvas);

        //canvas.Waller();
        /*
        Izgara izgara = new Izgara(cells, delay, startx, starty, finishx, finishy, tool, steps, length, CSIZE, searching, map);
        izgara.Waller(problemIndex ,null);
         */
        Update();

        searchB.addActionListener(new ActionListener() {		//ACTION LISTENERS
            @Override
            public void actionPerformed(ActionEvent e) {
                reset();
                if ((startx > -1 && starty > -1) && (finishx > -1 && finishy > -1)) {
                    searching = true;
                }
            }
        });
        resetB.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                resetMap();
                Update();
            }
        });
        genMapB.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                generateMap();
                Update();
            }
        });
        clearMapB.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                clearMap();
                Update();
            }
        });

        //LinkChangeB
        LinkChangeB.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {

                if (linkL.getText().equals("http://bilgisayar.kocaeli.edu.tr/prolab2/url1.txt")) {

                    linkL.setText("http://bilgisayar.kocaeli.edu.tr/prolab2/url2.txt");
                } else {
                    linkL.setText("http://bilgisayar.kocaeli.edu.tr/prolab2/url1.txt");
                }
            }
        });



        problemBx.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                problemIndex = problemBx.getSelectedIndex();
                if (problemIndex == 0) {
                    linkL.setText("URL");
                } else {
                    linkL.setText("Size");
                }

            }
        });

        speed.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                delay = speed.getValue();
                Update();
            }
        });

        startSearch();

    }



    public void startSearch() {	//START STATE

        if (searching) {
                    Alg.Algo();

        }
        pause();	//PAUSE STATE
    }

    public void pause() {	//PAUSE STATE
        System.out.println("----------------------------------- Stopped ---------------------------------------");
        int i = 0;
        while (!searching) {
            i++;
            if (i > 500) {
                i = 0;
            }
            try {
                Thread.sleep(1);
            } catch (Exception e) {
                System.out.println("PAUSE ERROR");
            }
        }
        startSearch();	//START STATE
    }

    public void Update() {	//UPDATE ELEMENTS OF THE GUI

        CSIZE = MSIZE / cells;
        canvas.repaint();
        msL.setText(delay + "ms");
        lengthL.setText("Path Length: " + length);

        stepL.setText("Checks: " + steps);
    }

    public void reset() {	//RESET METHOD
        searching = false;
        length = 0;
        steps = 0;
    }

    public void delay() {	//DELAY METHOD
        try {
            Thread.sleep(delay);
        } catch (Exception e) {
        }
    }

    class Map extends JPanel {	//MAP CLASS

        public void paintComponent(Graphics a) {	//REPAINT
            super.paintComponent(a);
            a.setColor(Color.decode("#030303")); // Black
            for (int x = 0; x < cells; x++) {	//PAINT EACH NODE IN THE GRID
                for (int y = 0; y < cells; y++) {
                    switch (map[x][y].getType()) {
                        case 0:
                            a.setColor(Color.GREEN);
                            break;
                        case 1:
                            a.setColor(Color.RED);
                            break;
                        case 2:
                            a.fillRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                            a.setColor(Color.decode("#030303"));
                            a.drawRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                            a.setColor(Color.ORANGE);
                            a.drawString(1 + "", x * CSIZE, (y * CSIZE) + 12);
                            a.setColor(Color.decode("#030303"));
                            break;
                        case 3:

                            if (map[x][y].getHidedType() == 7) {
                                //System.out.println("HIDED: " + x  + " " + y);
                                a.fillRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                                a.setColor(Color.decode("#030303"));
                                a.drawRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                                a.setColor(Color.PINK);
                                break;
                            }
                            if (map[x][y].getHidedType() == 9) {

                                a.fillRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                                a.setColor(Color.PINK);
                                a.drawRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                                a.setColor(Color.PINK);
                                break;
                            }
                            if (map[x][y].getHidedType() == 0) {
                                a.setColor(Color.GRAY);
                            }

                            break;
                        case 4:
                            a.setColor(Color.decode("#8F33FF")); // instead of CYAN
                            break;
                        case 5:
                            a.setColor(Color.YELLOW);
                            break;

                        case 6:
                            a.fillRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                            a.setColor(Color.decode("#030303"));
                            a.drawRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                            a.setColor(Color.ORANGE);
                            a.drawString(2 + "", x * CSIZE, (y * CSIZE) + 12);
                            a.setColor(Color.decode("#030303"));
                            break;

                        case 8:
                            a.fillRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                            a.setColor(Color.decode("#030303"));
                            a.drawRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                            a.setColor(Color.ORANGE);
                            a.drawString(3 + "", x * CSIZE, (y * CSIZE) + 12);
                            a.setColor(Color.decode("#030303"));
                            break;

                        case 55: // The Second algorithm movement
                            a.setColor(Color.decode("#8F33FF")); // instead of CYAN
                            break;
                    }
                    if ((map[x][y].getType() != 2) && (map[x][y].getType() != 6) && (map[x][y].getType() != 8)) {
                        a.fillRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                        a.setColor(Color.decode("#030303"));
                        a.drawRect(x * CSIZE, y * CSIZE, CSIZE, CSIZE);
                    }

                    //GREEN TEXT
                    if (map[x][y].getHidedType() == 7) {
                        a.setColor(Color.decode("#030303"));
                        a.drawString(2 + "", x * CSIZE, (y * CSIZE) + 12);
                        a.setColor(Color.decode("#030303"));
                    }

                    if (map[x][y].getHidedType() == 9) {
                        a.setColor(Color.decode("#030303"));
                        a.drawString(3 + "", x * CSIZE, (y * CSIZE) + 12);
                        a.setColor(Color.decode("#030303"));
                    }

                }
            }
        }

        public void StartAndEnd(int g, int p, int e, int r) {
            resetMap();	//RESET THE MAP WHENEVER CLICKED

            int tempStart = 1;

            for (int i = 0; i < 2; i++) {

                int x, y;

                if (tempStart == 1) { // Start
                    x = g;	// this should be random with maze wall check
                    y = p; // this should be random with maze wall check
                    tempStart = 11;
                    tool = 0;
                } else {  // End
                    x = e;	// this should be random with maze wall check
                    y = r;   // this should be random with maze wall check
                    tool = 1;
                }

                //System.out.println("IND: " + x + y);
                Node current = map[x][y];
                switch (tool) {
                    case 0: {	//START NODE
                        while ((current.getType() == 2) || (current.getType() == 6) || (current.getType() == 8) || (current.getHidedType() == 7) || (current.getHidedType() == 9)) {
                            x = ThreadLocalRandom.current().nextInt(0, cells);
                            y = ThreadLocalRandom.current().nextInt(0, cells);
                            current = map[x][y];
                        }
                        if ((current.getType() != 2) && (current.getType() != 6) && (current.getType() != 8)) {	//IF NOT WALL
                            if (startx > -1 && starty > -1) {	//IF START EXISTS SET IT TO EMPTY
                                map[startx][starty].setType(3);
                                map[startx][starty].setHops(-1);
                            }
                            current.setHops(0);
                            startx = x;	//SET THE START X AND Y
                            starty = y;
                            current.setType(0);	//SET THE NODE CLICKED TO BE START
                        }
                        break;
                    }
                    case 1: {//FINISH NODE
                        while ((current.getType() == 2) || (current.getType() == 6) || (current.getType() == 8) || (current.getHidedType() == 7) || (current.getHidedType() == 9)) {
                            x = ThreadLocalRandom.current().nextInt(0, cells);
                            y = ThreadLocalRandom.current().nextInt(0, cells);
                            current = map[x][y];
                        }
                        if ((current.getType() != 2) && (current.getType() != 6) && (current.getType() != 8)) {	//IF NOT WALL
                            if (finishx > -1 && finishy > -1) //IF FINISH EXISTS SET IT TO EMPTY
                            {
                                map[finishx][finishy].setType(3);
                            }
                            finishx = x;	//SET THE FINISH X AND Y
                            finishy = y;
                            current.setType(1);	//SET THE NODE CLICKED TO BE FINISH
                        }
                        break;
                    }
                    default:
                        if (current.getType() != 0 && current.getType() != 1) {
                            current.setType(tool);

                        }
                        break;
                }
                Update();

            }
        }
    }

    class Algorithm {	//ALGORITHM CLASS

        public void AStar() {
            int temp = delay;
            delay = 0;

            Robot2 robot2 = new Robot2(cells, steps, length, CSIZE, searching, map);
            ArrayList<Node> priority = new ArrayList<Node>();
            priority.add(map[startx][starty]);

            while (searching) { /// AHMAAAAAD

                if (priority.size() <= 0) {
                    searching = false;
                    break;
                }
                int hops = priority.get(0).getHops() + 1;
                RETURNER2 returner2 = robot2.exploreNeighbors(priority.get(0), hops);
                steps = returner2.getChecks();
                length = returner2.getLength();
                searching = returner2.getSolving();
                ArrayList<Node> explored = returner2.getExplored();

                if (explored.size() > 0) {
                    priority.remove(0);
                    priority.addAll(explored);
                    Update();
                    delay();

                } else {
                    priority.remove(0);

                }
                //sortQue(priority);	//SORT THE PRIORITY QUE

            }
            stopTime = System.nanoTime();
            // stop time
            if (startTime != 0) {
                long duration = stopTime - startTime;    //calculate the elapsed time

                double FinalTime = (double) duration / 1000000000;   //convert to ms
                System.out.println(String.format("Time %1.3f Seconds", FinalTime));

                //textDfs.setText(String.format("%1.3f ms", dfsTime));
                TimingL.setText(String.format("Elapsed Time: %1.3f Seconds", FinalTime));
            }

            delay = temp;
        }

        public void Algo() {
            
            if (delay == 0) {
                startTime = System.nanoTime();
                //System.out.println("++++++++++++++++++++++++++++++++++++++++++++ " + elapsedSeconds);
            }

            Robot robot = new Robot(cells, steps, length, CSIZE, searching, map);

            ArrayList<Node> priority = new ArrayList<Node>();

            ArrayList<Node> explored2 = new ArrayList<Node>();

            boolean up = false;
            boolean left = false;
            boolean right = false;
            boolean down = false;

            RETURNER returner = null;
            ArrayList<Node> explored = null;

            ArrayList<Node> toBeExplored = new ArrayList<Node>();

            priority.add(map[startx][starty]);
            
            while (searching) { /// AHMAAAAAD

                int aX = 0;
                int bX = 0;

                System.out.println("STATUS-> " + "Up: " + right + ", Left: " + left + ", Right: " + right + ", Down: " + down);

                boolean Ocheck = false;
                boolean Icheck = false;

                if (((!Ocheck) || (!Icheck)) && (!left) && (!right) && (!down)) {
                    System.out.println("COMONNNN");
                }

                if (priority.size() <= 0) {
                    searching = false;
                    break;
                }
                System.out.println("O COMONN");
                int hops = priority.get(0).getHops() + 1;

                if (((!Ocheck) || (!Icheck)) && (!left) && (!right) && (!down)) {

                    returner = robot.exploreNeighbors(priority.get(0), hops, aX, bX - 1, explored2);
                    Ocheck = returner.getOcheck();
                    Icheck = returner.getIcheck();
                    steps = returner.getChecks();
                    length = returner.getLength();
                    searching = returner.getSolving();
                    explored = returner.getExplored();

                    System.out.println("Up");

                    if (Icheck) {
                        up = true;
                    } else {
                        up = false;
                    }
                }
                if (((!Ocheck) || (!Icheck)) && (!up) && (!right) && (!down)) {
                    returner = robot.exploreNeighbors(priority.get(0), hops, aX - 1, bX, explored2);
                    Ocheck = returner.getOcheck();
                    Icheck = returner.getIcheck();
                    steps = returner.getChecks();
                    length = returner.getLength();
                    searching = returner.getSolving();
                    explored = returner.getExplored();

                    System.out.println("Left");

                    if (Icheck) {
                        left = true;
                    } else {
                        left = false;
                    }
                }
                if (((!Ocheck) || (!Icheck)) && (!left) && (!down) && (!up)) {
                    returner = robot.exploreNeighbors(priority.get(0), hops, aX + 1, bX, explored2);
                    Ocheck = returner.getOcheck();
                    Icheck = returner.getIcheck();
                    steps = returner.getChecks();
                    length = returner.getLength();
                    searching = returner.getSolving();
                    explored = returner.getExplored();

                    System.out.println("Right");

                    if (Icheck) {
                        right = true;
                    } else {
                        right = false;
                    }

                    System.out.println("Icheck: " + Icheck);
                }

                if (((!Ocheck) || (!Icheck)) && (!right)) {
                    returner = robot.exploreNeighbors(priority.get(0), hops, aX, bX + 1, explored2);
                    Ocheck = returner.getOcheck();
                    Icheck = returner.getIcheck();
                    steps = returner.getChecks();
                    length = returner.getLength();
                    searching = returner.getSolving();
                    explored = returner.getExplored();

                    System.out.println("Down");

                    if (Icheck) {
                        down = true;
                    } else {
                        down = false;
                    }
                }

                if (!(toBeExplored.isEmpty() && returner.getToBeExplored().isEmpty())) {
                    for (int i = 0; i < returner.getToBeExplored().size(); i++) {
                        toBeExplored.add(returner.getToBeExplored().get(i));
                        System.out.println("ADDDED");
                    }
                }

                for (int i = 0; i < toBeExplored.size(); i++) {
                    if (toBeExplored.get(i).getType() == 4) {
                        toBeExplored.remove(i);
                    }
                }

                if (explored.size() > 0) {
                    priority.remove(0);
                    priority.addAll(explored);
                    Update();
                    delay();

                } else {

                    System.out.println("TO ELSEE  " + toBeExplored.size());

                    if (!toBeExplored.isEmpty()) {
                        System.out.println("TELEPORTING...");
                        int AA;
                        int BB;
                        int minIndex = 0;
                        int min = 1000;

                        for (int i = 0; i < toBeExplored.size(); i++) {
                            AA = priority.get(0).getX() - toBeExplored.get(i).getX();
                            BB = priority.get(0).getY() - toBeExplored.get(i).getY();
                            int AA2 = Math.abs(AA);
                            int BB2 = Math.abs(BB);
                            if ((AA2 + BB2) < min) {
                                min = AA2 + BB2;
                                minIndex = i;
                            }

                        }

                        AA = priority.get(0).getX() - toBeExplored.get(minIndex).getX();
                        BB = priority.get(0).getY() - toBeExplored.get(minIndex).getY();

                        System.out.println("AA: " + toBeExplored.get(minIndex).getX() + " BB: " + toBeExplored.get(minIndex).getY());

                        returner = robot.exploreNeighbors(priority.get(0), hops, -AA, -BB, explored2);
                        Ocheck = returner.getOcheck();
                        Icheck = returner.getIcheck();
                        steps = returner.getChecks();
                        length = returner.getLength();
                        searching = returner.getSolving();
                        explored = returner.getExplored();

                        if (!(toBeExplored.isEmpty() && returner.getToBeExplored().isEmpty())) {
                            for (int i = 0; i < returner.getToBeExplored().size(); i++) {
                                toBeExplored.add(returner.getToBeExplored().get(i));
                                System.out.println("ADDDED");
                            }
                        }

                        for (int i = 0; i < toBeExplored.size(); i++) {
                            if (toBeExplored.get(i).getType() == 4) {
                                toBeExplored.remove(i);
                            }
                        }

                        priority.remove(0);
                        priority.addAll(explored);
                        Update();
                        delay();
                    }

                    if (steps == 10000) {
                        priority.remove(0);
                    }

                }
                
            }

            searching = true;

            Update();
            
            steps--; // just one time at the end
            
            Alg.AStar();
        }

    }

}

// Izgara Class

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */

import java.awt.Graphics;
import java.awt.Color;
import java.util.Random;
import javax.swing.JPanel;

/**
 *
 * @author pooqw
 */
class Izgara{	//MAP CLASS

    private int cells;
    private int delay;
    private int startx;
    private int starty;
    private int finishx;
    private int finishy;
    private int tool;
    private int checks;
    private int length;
    private int curAlg;
    private int WIDTH0;
    private int CSIZEs;
    private boolean solving;
    Node[][] map;

    public Izgara(int cells, int delay, int startx, int starty, int finishx, int finishy, int tool, int checks, int length, int CSIZEs, boolean solving, Node[][] map) {
        this.cells = cells;
        this.delay = delay;
        this.startx = startx;
        this.starty = starty;
        this.finishx = finishx;
        this.finishy = finishy;
        this.tool = tool;
        this.checks = checks;
        this.length = length;
        this.curAlg = curAlg;
        this.WIDTH0 = WIDTH0;
        this.CSIZEs = CSIZEs;
        this.solving = solving;
        this.map = map;

        //PathFinding.CCC++;
    }

    public StartAndEndPos Waller(int problemIndex, String link) { // Walling from text file

        /*
            int[][] maze
                 = {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, // 13 // 13
                    {1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1},
                    {1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1},
                    {1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1},
                    {1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1},
                    {1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1},
                    {1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1},
                    {1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}

                    };
         */
 /*
            int[][] maze
                 = {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, // 13 // 13
                    {1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1},
                    {1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1},
                    {1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1},
                    {1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1},
                    {1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
                    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}

                    };
         */
 /*
            int[][] maze={
                                        {0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0},
					{0,1,0,0,1,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,0,0,0},
					{0,1,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0},
					{0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,0,0},
					{0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,1,0,0,1,1,0,1,0,0},
					{0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0},
					{0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0},
					{0,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,1,1,1,0},
					{0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0},
					{0,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0},
					{0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0},
					{0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0},
					{0,0,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,0,0},
					{0,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0},
					{0,0,1,0,0,1,1,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,0},
					{0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,1,1,0},
					{0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0},
					{0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0},
					{0,1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,0,1,1,1,1,1,0,0},
					{0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
					{0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0},
					{0,1,1,1,0,1,0,0,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0},
					{0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0}};
         */
        int maze[][] = null;
        if (problemIndex == 0) {
            URLTextReader Utr = new URLTextReader();
            maze = Utr.Reader(link);
            

            if (maze == null) {
                System.out.println("***** URLTextReader Error *****");
            }

        } else {
            Labyrenther g = new Labyrenther();
            g.initializeGrid(true, cells, cells);
            maze = g.getGrid();
        }

        System.out.println("i: " + maze.length + " j: " + maze[0].length);

        tool = 2;
        StartAndEndPos SAEP = new StartAndEndPos();
        


        for (int x = 0; x < maze[0].length; x++) {
            for (int y = 0; y < maze.length; y++) {
                
                Random rd = new Random(); // creating Random object
                //System.out.println(rd.nextBoolean()); // displaying a random boolean
                boolean random[] = new boolean[9];
                
                for (int i = 0; i < 9; i++) {
                    random[i] = rd.nextBoolean();      
                }
                
                // Empty Blocker
                
                    random[0]=false;
                    random[2]=false;
                    random[7]=false;
                    random[8]=false;
                
                
                // CHAPRAZ 2 Checkers
                if( (!random[0]) && (!random[3]))
                {
                    random[1]=false;
                }
                
                if( (!random[1]) && (!random[2]))
                {
                    random[0]=false;
                }
                // Chapraz 2 checkers ending
                
                /*
                  2  2
                  2  2
                
                
                 3  3  3
                 3  3  3
                 3  3  3
                
                */
                
                /*
                for (int i = 0; i < 6; i++) {
                    
                    if(random[i] && (random[i+1] || random[i+3]))
                    {
                        
                    }
                    else
                    {
                        random[i] = true;
                        random[i+1]=true;
                    }
                    
                }
                */

                
                if (problemIndex == 0) {
                    
                    /*
                    System.out.println("PROBLEM 0 (1)" + maze[x][y]);
                    System.out.println("map: " + map[x][y].getType());
                    */
                    
                    /// 1 2 3 engel
                    
                    if ((maze[x][y] == 1) && (map[x][y].getType()==3)) {
                        map[x][y] = new Engel(2, x, y, finishx, finishy);
                        Engel current = (Engel) map[x][y];
                        
                    }
                    if ((maze[x][y] == 2) && (map[x][y].getType()==3) && (map[x][y].getHidedType() != 7)) {
                        
                        int count=0;
                        for (int i = 0; i < 2; i++) {
                            for (int j = 0; j < 2; j++) {
                                
                                if(random[count])
                                {
                                    map[x+i][y+j].setHidedType(7);
                                    
                                }
                                else
                                {
                                    map[x+i][y+j] = new Engel(6, x, y, finishx, finishy);
                                    Node current = (Node) map[x+i][y+j];
                                }
                                
                                
                                count++;
                            }
                            
                        }
                        
                            /* CAPRAZ CHECKING
                                if((map[x][y].getType()== 6) && (map[x+1][y+1].getType() == 6) && ((map[x+1][y].getType() != 6) || (map[x][y+1].getType() != 6)))
                                {
                                    map[x+1][y] = new Engel(6, x+1, y, finishx, finishy);
                                    Engel current = (Engel) map[x+1][y];
                                }
                                
                                if((map[x][y+1].getType()== 6) && (map[x+1][y].getType() == 6) && ((map[x][y].getType() != 6) || (map[x+1][y+1].getType() != 6)))
                                {
                                    map[x][y] = new Engel(6, x, y, finishx, finishy);
                                    Engel current = (Engel) map[x][y];
                                }
                                
                            */
                        
                        
                        
                    }
                    if ((maze[x][y] == 3) && (map[x][y].getType()==3) && (map[x][y].getHidedType() != 9) ) {
                        int count=0;
                        for (int i = 0; i < 3; i++) {
                            for (int j = 0; j < 3; j++) {
                                
                                if(random[count])
                                {
                                    map[x+i][y+j].setHidedType(9);
                                    
                                }
                                else
                                {
                                    map[x+i][y+j] = new Engel(8, x, y, finishx, finishy);
                                    Node current = (Node) map[x+i][y+j];
                                }
                                
                                
                                count++;
                            }
                            
                        }
                       
                        
                    }
                }
                // Problem 2
                else{
                    if (maze[x][y] == 1) {
                        map[x][y] = new Engel(2, x, y, finishx, finishy);
                        //System.out.println("C: " + map[x][y].getType());
                        Engel current = (Engel) map[x][y];
                        //System.out.println("E: " + current.getType());
                        if (current.getType() != 0 && current.getType() != 1) {
                            current.setType(tool);
                        }
                    }
                    if (maze[x][y] == 2) {
                        SAEP.setStartX(x);
                        SAEP.setStartY(y);

                    }
                    if (maze[x][y] == 3) {
                        SAEP.setEndX(x);
                        SAEP.setEndY(y);
                    }
                }

            }
        }
        SAEP.setMap(map);
        SAEP.setMaze(maze);
        return SAEP;
    }
    
    

}

class StartAndEndPos {

    private int StartX;
    private int StartY;
    private int EndX;
    private int EndY;
    private Node map[][];
    private int maze[][];

    public int[][] getMaze() {
        return maze;
    }

    public void setMaze(int[][] maze) {
        this.maze = maze;
    }
    
    
    public Node[][] getMap() {
        return map;
    }

    public void setMap(Node[][] map) {
        this.map = map;
    }

    public void setStartX(int StartX) {
        this.StartX = StartX;
    }

    public void setStartY(int StartY) {
        this.StartY = StartY;
    }

    public void setEndX(int EndX) {
        this.EndX = EndX;
    }

    public void setEndY(int EndY) {
        this.EndY = EndY;
    }

    public int getStartX() {
        return StartX;
    }

    public int getStartY() {
        return StartY;
    }

    public int getEndX() {
        return EndX;
    }

    public int getEndY() {
        return EndY;
    }

}

// Labyrenther 

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 */

import java.awt.Point;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

/**
 *
 * @author pooqw
 */
public class Labyrenther {
    
    
        int squareSize;  // the size of the square cell in pixels


        
        ArrayList<Cell> openSet   = new ArrayList();// the OPEN SET
        ArrayList<Cell> closedSet = new ArrayList();// the CLOSED SET
        
         
        Cell robotStart; // the initial position of the robot
        Cell targetPos;  // the position of the target
      
                
        int[][] grid;        // the grid
        Point[][] centers;   // the centers of the cells
        boolean searching;   // flag that the search is in progress
        boolean endOfSearch; // flag that the search came to an end

    public int[][] getGrid() {
        return grid;
    }
    
    private class Cell {
            int row;     // the row number of the cell(row 0 is the top)
            int col;     // the column number of the cell (Column 0 is the left)
            
            
            public Cell(int row, int col){
               this.row = row;
               this.col = col;
            }
            
        } // end nested class Cell
    
    /// This run first
    void initializeGrid(Boolean makeMaze,int rows, int columns) {  
            grid = new int[rows][columns];
            System.out.println(grid.length);
            
            boolean G = true;
            // the square maze must have an odd number of rows
            // the rows of the triangular maze must be at least 8 and a multiple of 4 
            if (makeMaze && (G? rows % 2 != 1 : rows % 4 != 0)){
                if (G)
                    rows--;
                else
                    rows = Math.max((rows/4)*4,8);
                
            }
            // a hexagonal grid must have an odd number of columns
            
            // the columns of the triangular maze must be rows+1
            
            // the columns of the square maze must be equal to rows
            if (makeMaze){
                columns = rows;
                
            }
            grid = new int[rows][columns];
            centers = new Point[rows][columns];
           

            //  Calculation of the edge and the height of the triangular cell
            
            
            //  Calculation of the size of the square cell
            if (makeMaze){
                squareSize = 500/(rows > columns ? rows : columns);
            }
            
            //  Calculation of the radius and the half height of the hexagonal cell
            
            
            //  Calculation of the coordinates of the cells' centers

            for (int r = 0; r < rows; r++)
                for (int c = 0; c < columns; c++){
                    
                    if (makeMaze)
                        centers[r][c] = new Point(11+c*squareSize+squareSize/2,
                                                  11+r*squareSize+squareSize/2);
                    
                }
            fillGrid(grid,robotStart,targetPos,rows,columns);
            if (makeMaze) {
                
                    MazeGenerator maze = new MazeGenerator(rows/2,columns/2);
                    for (int r = 0; r < rows; r++)
                        for (int c = 0; c < columns; c++)
                            if (maze.maze_str.substring(r*columns+c, r*columns+c+1).matches(".*[+-|].*"))
                                grid[r][c] = 1;
                    
                    System.out.println("ZZZZ");
                    for (int i = 0; i < grid.length; i++) {
                        for (int j = 0; j < grid[0].length; j++) {
                            System.out.print(grid[i][j] + " ");
                        }
                        System.out.println("");
                    }
                    
              
            }
          } // end initializeGrid()
    
    private void fillGrid(int grid [][],Cell robotStart2 ,Cell targetPos2, int rows,int columns) {
            /**
             * With the first click on button 'Clear' clears the data
             * of any search was performed (Frontier, Closed Set, Route)
             * and leaves intact the obstacles and the robot and target positions
             * in order to be able to run another algorithm
             * with the same data.
             * With the second click removes any obstacles also.
             */
            if (searching || endOfSearch){ 
                for (int r = 0; r < rows; r++)
                    for (int c = 0; c < columns; c++) {
                        if (grid[r][c] == 4 || grid[r][c] == 5 || grid[r][c] == 6)
                            grid[r][c] = 0;
                        if (grid[r][c] == 2)
                            robotStart2 = new Cell(r,c);
                        if (grid[r][c] == 3)
                            targetPos2 = new Cell(r,c);
                    }
                searching = false;
            } else {
                for (int r = 0; r < rows; r++)
                    for (int c = 0; c < columns; c++)
                        grid[r][c] = 0;
                
                    System.out.println("AA: " + rows);
                    System.out.println("AA2: " + columns);
                    robotStart2 = new Cell(1,1);
                    targetPos2 = new Cell(rows-2,columns-2);
                

            }
         
            // The first step of the other four algorithms is here
            // 1. OPEN SET: = [So], CLOSED SET: = []
            openSet.removeAll(openSet);
            openSet.add(robotStart2);
            closedSet.removeAll(closedSet);
         
            
            grid[targetPos2.row][targetPos2.col] = 3; 
            grid[robotStart2.row][robotStart2.col] = 2;
            
            
        } // end fillGrid()
    
    final static class MazeGenerator {
            private final int x;
            private final int y;
            private final int[][] maze;
            private String maze_str = "";
            
            
 
            public MazeGenerator(int x, int y) {
                this.x = x;
                this.y = y;
                maze = new int[this.x][this.y];
                generateMaze(0, 0);
                
                for (int i = 0; i < maze.length; i++) {
                    for (int j = 0; j < maze[0].length; j++) {
                        System.out.print(maze[i][j] + " ");
                    }
                    System.out.println("");
                }
                
                make_string();
            }
 
            public void make_string() {
                for (int i = 0; i < y; i++) {
                    // draw the north edge
                    for (int j = 0; j < x; j++)
                        maze_str = maze_str.concat((maze[j][i] & 1) == 0 ? "+-" : "+ ");
                    maze_str = maze_str.concat("+");
                    // draw the west edge
                    for (int j = 0; j < x; j++)
                        maze_str = maze_str.concat((maze[j][i] & 8) == 0 ? "| " : "  ");
                    maze_str = maze_str.concat("|");
                }
                // draw the bottom line
                for (int j = 0; j < x; j++)
                    maze_str = maze_str.concat("+-");
                maze_str = maze_str.concat("+");
                
                
            }
 
            private void generateMaze(int cx, int cy) {
                DIR[] dirs = DIR.values();
                Collections.shuffle(Arrays.asList(dirs));
                for (DIR dir : dirs) {
                    int nx = cx + dir.dx;
                    int ny = cy + dir.dy;
                    if (between(nx, x) && between(ny, y) && (maze[nx][ny] == 0)) {
                        maze[cx][cy] |= dir.bit;
                        maze[nx][ny] |= dir.opposite.bit;
                        generateMaze(nx, ny);
                    }
                }
            }
 
            private static boolean between(int v, int upper) {
                return (v >= 0) && (v < upper);
            }
 
            private static enum DIR {
                N(1, 0, -1), S(2, 0, 1), E(4, 1, 0), W(8, -1, 0);
                private final int bit;
                private final int dx;
                private final int dy;
                private DIR opposite;
 
                // use the static initializer to resolve forward references
                static {
                    N.opposite = S;
                    S.opposite = N;
                    E.opposite = W;
                    W.opposite = E;
                }
 
                private DIR(int bit, int dx, int dy) {
                    this.bit = bit;
                    this.dx = dx;
                    this.dy = dy;
                }
            };
        } // end nested class MazeGenerator
    
}


// Engel Class

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */

/**
 *
 * @author pooqw
 */
public class Engel extends Node {
    
    /*
      0 = start, 1 = finish, 2 = wall, 3 = empty, 4 = checked, 5 = finalpath,
      6 = Engel 2 , 7 = Engel 2 Hided, 8 = Engel 3, 8 = Engel 3 Hided  
    */
    
        private int cellType;
        private int hops;
        private int x;
        private int y;
        private int lastX;
        private int lastY;
        private int finishx;
        private int finishy;

        public Engel (int type, int x, int y,int finishx , int finishy) {	//CONSTRUCTOR
            super(type, x, y, finishx, finishy);
            this.cellType = type;
        }

    @Override
    public void setHidedType(int HidedType) {
        super.setHidedType(HidedType); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/OverriddenMethodBody
    }

    @Override
    public int getHidedType() {
        return super.getHidedType(); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/OverriddenMethodBody
    }


        public int getX() {
            return x;
        }		//GET METHODS

        public int getY() {
            return y;
        }

        public int getLastX() {
            return lastX;
        }

        public int getLastY() {
            return lastY;
        }

        @Override
        public int getType() {
            return cellType;
        }

        public int getHops() {
            return hops;
        }

        @Override
        public void setType(int type) {
            cellType = type;
        }		//SET METHODS

        public void setLastNode(int x, int y) {
            lastX = x;
            lastY = y;
        }

        public void setHops(int hops) {
            this.hops = hops;
        }
    
    
}

// Node Class

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */

/**
 *
 * @author pooqw
 */
class Node {
    
    /*
      0 = start, 1 = finish, 2 = wall, 3 = empty, 4 = checked, 5 = finalpath,
      6 = Engel 2 , 7 = Engel 2 Hided, 8 = Engel 3, 8 = Engel 3 Hided  
    */
    
        private int cellType;
        private int hops;
        private int x;
        private int y;
        private int lastX;
        private int lastY;
        private int finishx;
        private int finishy;
        private int HidedType;

        public Node (int type, int x, int y,int finishx , int finishy) {	//CONSTRUCTOR
            this.cellType = type;
            this.x = x;
            this.y = y;
            hops = -1;
            this.finishx = finishx;
            this.finishy = finishy;
        }

    public int getHidedType() {
        return HidedType;
    }

    public void setHidedType(int HidedType) {
        this.HidedType = HidedType;
    }


        public int getX() {
            return x;
        }		//GET METHODS

        public int getY() {
            return y;
        }

        public int getLastX() {
            return lastX;
        }

        public int getLastY() {
            return lastY;
        }

        public int getType() {
            return cellType;
        }

        public int getHops() {
            return hops;
        }

        public void setType(int type) {
            cellType = type;
        }		//SET METHODS

        public void setLastNode(int x, int y) {
            lastX = x;
            lastY = y;
        }

        public void setHops(int hops) {
            this.hops = hops;
        }
}

// Robot Class





import java.util.ArrayList;

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
/**
 *
 * @author pooqw
 */
class Robot {	//ALGORITHM CLASS

    //PathFinding pathfinding = new PathFinding();  // it can't be: PathFinding pathfinding = new PathFinding() BECAUSE IT MAKES A LOOP 
    private int cells;

    private int checks;
    private int length;
;

    private boolean solving;
    Node[][] map;

    public Robot(int cells,int checks, int length, int CSIZE, boolean solving, Node[][] map) {
        this.cells = cells;
        this.checks = checks;
        this.length = length;
        this.solving = solving;
        this.map = map;

        //PathFinding.CCC++;
    }

    public Robot() {
    }

    private boolean pravista = false;

    public RETURNER exploreNeighbors(Node current, int hops, int a, int b, ArrayList<Node> explored2) {	//EXPLORE NEIGHBORS
        ArrayList<Node> explored = new ArrayList<Node>();	//LIST OF NODES THAT HAVE BEEN EXPLORED
        ArrayList<Node> toBeExplored = new ArrayList<Node>();

        boolean Ocheck = false;
        boolean Icheck = false;

        int xbound = current.getX() + a;
        int ybound = current.getY() + b;

        System.out.println("\nOFUNC");
        if ((xbound > -1 && xbound < cells) && (ybound > -1 && ybound < cells)) {	//MAKES SURE THE NODE IS NOT OUTSIDE THE GRID
            System.out.println("FUNC");
            Ocheck = true;
            Node neighbor = map[xbound][ybound];

            

            /*
                        if(explored2.contains(neighbor) && (neighbor.getType() == 4) && hops == 26)
                           {
                               Icheck = true;
                               System.out.println("GGGGGGGG");
                               Icheck = true;
                            explore(neighbor, current.getX(), current.getY(), hops);	//EXPLORE THE NODE
                            explored.add(neighbor);	//ADD THE NODE TO THE LIST
                               
                           }
             */
            for (int k = -1; k <= 1; k++) {
                for (int s = -1; s <= 1; s++) {
                    if ((k == 1 && s == 0) || (k == 0 && s == 1) || (k == -1 && s == 0) || (k == 0 && s == -1)) {
                        int xbound2 = current.getX() + k;
                        int ybound2 = current.getY() + s;
                        if ((xbound2 > -1 && xbound2 < cells) && (ybound2 > -1 && ybound2 < cells)) {
                            Node neighbor5 = map[xbound2][ybound2];

                            if( neighbor5.getType() == 1)
                            {

                                toBeExplored.clear();
                                explore(neighbor5, current.getX(), current.getY(), hops, false);	//EXPLORE THE NODE
                                explored.add(neighbor5);	//ADD THE NODE TO THE LIST
                                solving= false;
                                RETURNER returner = new RETURNER(explored, toBeExplored, length, solving, checks, Ocheck, Icheck);
                                return returner;
                                
                            }
                        }
                    }

                }
            }
            
            
            
            System.out.println("------>>>: " + neighbor.getHops());
            System.out.println("------>>>2: " + hops);
            System.out.println("------>>>3: " + neighbor.getType());
            System.out.println("POS: " + xbound + " " + ybound);
            System.out.println("type: " + neighbor.getType());

            if ((neighbor.getHops() == -1 || neighbor.getHops() > hops) && (neighbor.getType() != 2) && (neighbor.getType() != 6) && (neighbor.getType() != 8)) {	//CHECKS IF THE NODE IS NOT A WALL AND THAT IT HAS NOT BEEN EXPLORED
                Icheck = true;
                System.out.println("IFUNC");
                explore(neighbor, current.getX(), current.getY(), hops, false);	//EXPLORE THE NODE
                explored.add(neighbor);	//ADD THE NODE TO THE LIST

            }
            
            /// toBeExplored
            outerloop:
            for (int k = -1; k <= 1; k++) {
                for (int s = -1; s <= 1; s++) {
                    if ((k == 1 && s == 0) || (k == 0 && s == 1) || (k == -1 && s == 0) || (k == 0 && s == -1)) {
                        int xbound2 = current.getX() + k;
                        int ybound2 = current.getY() + s;
                        if ((xbound2 > -1 && xbound2 < cells) && (ybound2 > -1 && ybound2 < cells)) {
                            Node neighbor2 = map[xbound2][ybound2];
                            if (neighbor2.getType() == 3) {
                                System.out.println("ADDED in FUNC");
                                toBeExplored.add(neighbor2);
                            }//  neighbor2.getType() == 1
                            if( neighbor2.getType() == 1)
                            {

                                toBeExplored.clear();
                                explore(neighbor2, current.getX(), current.getY(), hops, false);	//EXPLORE THE NODE
                                explored.add(neighbor2);	//ADD THE NODE TO THE LIST
                                solving= false;
                                break outerloop;
                            }
                        }
                    }

                }
            }
            
            System.out.println("POSXX: " + xbound + " " + ybound);
            System.out.println("type: " + neighbor.getType());
            

            /*
                        if((neighbor.getHops() != -1 && neighbor.getHops() < hops) && (explored2.contains(neighbor)))
                           {
                               Icheck = true;
                               System.out.println("KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKLLLL");
                               
                               
                           }
             */
            // continue by else with a++ or b++
        } else {
            System.out.println("FOUNDERS");
        }
        
        System.out.println("******");

        RETURNER returner = new RETURNER(explored, toBeExplored, length, solving, checks, Ocheck, Icheck);
        return returner;
    }

    public void explore(Node current, int lastx, int lasty, int hops, boolean fakeTrack) {	//EXPLORE A NODE
        if (current.getType() != 0 && current.getType() != 1) //CHECK THAT THE NODE IS NOT THE START OR FINISH
        {
            current.setType(4);	//SET IT TO EXPLORED
        }
        current.setLastNode(lastx, lasty);	//KEEP TRACK OF THE NODE THAT THIS NODE IS EXPLORED FROM
        current.setHops(hops);	//SET THE HOPS FROM THE START

        if (!fakeTrack) {
            checks++;
        } else {

        }

        System.out.println(checks);

        if (current.getType() == 1) {	//IF THE NODE IS THE FINISH THEN BACKTRACK TO GET THE PATH
            backtrack(current.getLastX(), current.getLastY(), hops);
            System.out.println("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"); // by Ahmadista
            pravista = true;

        }
    }

    public void backtrack(int lx, int ly, int hops) {	//BACKTRACK

        length = hops;
        while (hops > 1) {	//BACKTRACK FROM THE END OF THE PATH TO THE START
            Node current = map[lx][ly];
            //current.setType(5);
            lx = current.getLastX();
            ly = current.getLastY();
            hops--;
        }
        solving = false;
    }
}

class RETURNER {

    private ArrayList<Node> explored;
    private ArrayList<Node> toBeExplored;
    private int length;
    private boolean solving;
    private int checks;
    private boolean Ocheck;
    private boolean Icheck;

    public RETURNER(ArrayList<Node> explored, ArrayList<Node> toBeExplored, int length, boolean solving, int checks, boolean Ocheck, boolean Icheck) {
        this.explored = explored;
        this.toBeExplored = toBeExplored;
        this.length = length;
        this.solving = solving;
        this.checks = checks;
        this.Ocheck = Ocheck;
        this.Icheck = Icheck;
    }

    public RETURNER() {

    }

    public boolean getOcheck() {
        return Ocheck;
    }

    public boolean getIcheck() {
        return Icheck;
    }

    public ArrayList<Node> getToBeExplored() {
        return toBeExplored;
    }

    public ArrayList<Node> getExplored() {
        return explored;
    }

    public int getLength() {
        return length;
    }

    public boolean getSolving() {
        return solving;
    }

    public int getChecks() {
        return checks;
    }

}




// Robot2 Class


import java.util.ArrayList;

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */

/**
 *
 * @author pooqw
 */
public class Robot2 {
    //PathFinding pathfinding = new PathFinding();  // it can't be: PathFinding pathfinding = new PathFinding() BECAUSE IT MAKES A LOOP 
    
    
    
        //PathFinding pathfinding = new PathFinding();  // it can't be: PathFinding pathfinding = new PathFinding() BECAUSE IT MAKES A LOOP 
    private int cells;
    private int checks;
    private int length;
;

    private boolean solving;
    Node[][] map;

    public Robot2(int cells,int checks, int length, int CSIZE, boolean solving, Node[][] map) {
        this.cells = cells;
        this.checks = checks;
        this.length = length;
        this.solving = solving;
        this.map = map;

        //PathFinding.CCC++;
    }

    
    
    private boolean pravista=false;

        public RETURNER2 exploreNeighbors(Node current, int hops) {	//EXPLORE NEIGHBORS
            ArrayList<Node> explored = new ArrayList<Node>();	//LIST OF NODES THAT HAVE BEEN EXPLORED
            
            outerloop:
            for (int a = -1; a <= 1; a++) {
                for (int b = -1; b <= 1; b++) {
                    if((a==1 && b==0) || (a==0 && b==1) || (a==-1 && b==0) || (a==0 && b==-1))
                    {
                       int xbound = current.getX() + a;
                       int ybound = current.getY() + b;
                    
                    if ((xbound > -1 && xbound < cells) && (ybound > -1 && ybound < cells)) {	//MAKES SURE THE NODE IS NOT OUTSIDE THE GRID
                        Node neighbor = map[xbound][ybound];
                        
                        
                        
                        
                        if ((neighbor.getType() != 2) && (neighbor.getType() != 55) && (neighbor.getType() != 3) && (neighbor.getType() != 6) && (neighbor.getType() != 8)) {	//CHECKS IF THE NODE IS NOT A WALL AND THAT IT HAS NOT BEEN EXPLORED
                            explore(neighbor, current.getX(), current.getY(), hops);	//EXPLORE THE NODE
                            explored.add(neighbor);	//ADD THE NODE TO THE LIST
                            System.out.println("POSXX22: " + xbound + " " + ybound);
                            System.out.println("type: " + neighbor.getType());
                            System.out.println("hops: " + neighbor.getHops());
                            
                            if(!solving)
                                break outerloop;
                        }
                        // continue by else with a++ or b++
                    } 
                    }
                    
                    
                }
            }
            
            System.out.println("******");
            
            RETURNER2 returner = new RETURNER2(explored, length, solving, checks);
            return returner;
        }

        public void explore(Node current, int lastx, int lasty, int hops) {	//EXPLORE A NODE
            if (current.getType() != 0 && current.getType() != 1) //CHECK THAT THE NODE IS NOT THE START OR FINISH
            {
                current.setType(4);	//SET IT TO EXPLORED
            }
            if (current.getType() == 4) //CHECK THAT THE NODE IS NOT THE START OR FINISH
            {
                current.setType(55);	//SET IT TO EXPLORED
            }
            
            
            
            current.setLastNode(lastx, lasty);	//KEEP TRACK OF THE NODE THAT THIS NODE IS EXPLORED FROM
            current.setHops(hops);	//SET THE HOPS FROM THE START
            
            System.out.println(checks);
            
            if (current.getType() == 1) {	//IF THE NODE IS THE FINISH THEN BACKTRACK TO GET THE PATH
                backtrack(current.getLastX(), current.getLastY(), hops);
                System.out.println("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"); // by Ahmadista
                solving = false;
                pravista=true;
                return;
                
            }
        }

        public void backtrack(int lx, int ly, int hops) {	//BACKTRACK
            
            length = hops++;
            while (hops > 2) {	//BACKTRACK FROM THE END OF THE PATH TO THE START
                Node current = map[lx][ly];
                current.setType(5);
                lx = current.getLastX();
                ly = current.getLastY();
                hops--;
            }
            length-=1; // CHANGING THE LAST LENGTH
            solving = false;
        }
}

class RETURNER2
{
    private ArrayList<Node> explored;
    private int length;
    private boolean solving;
    private int checks;

    public RETURNER2(ArrayList<Node> explored, int length, boolean solving, int checks) {
        this.explored = explored;
        this.length = length;
        this.solving = solving;
        this.checks = checks;
    }

    public ArrayList<Node> getExplored() {
        return explored;
    }

    public int getLength() {
        return length;
    }

    public boolean getSolving() {
        return solving;
    }

    public int getChecks() {
        return checks;
    }
    
    
}

// URLTextReader Class


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;

public class URLTextReader {

    public int[][] Reader(String link) {

        ArrayList<String> lines = new ArrayList<>();
        int maze[][] = null;

        try {

            URL url = new URL(link); //http://bilgisayar.kocaeli.edu.tr/prolab2/url1.txt

            // read text returned by server
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));

            String line;

            while ((line = in.readLine()) != null) {
                System.out.println(line);
                lines.add(line);

            }
            maze = new int[lines.size()][lines.get(0).length()];

            for (int i = 0; i < maze.length; i++) {
                for (int j = 0; j < maze[0].length; j++) {
                    maze[i][j] = Integer.parseInt(lines.get(j).charAt(i) + "");

                }
            }
            
            // Green Random Box
            // 22 
            /*
            for (int i = 0; i < maze.length; i++) {
                for (int j = 0; j < maze[0].length; j++) {
                    
                    if(maze[i][j] == 2)
                    {
                        maze[i][j] = 6;
                    }
                    

                }
            }
            */
            

            in.close();

        } catch (MalformedURLException e) {
            System.out.println("Malformed URL: " + e.getMessage());
        } catch (IOException e) {
            System.out.println("I/O Error: " + e.getMessage());
        }

        return maze;

    }

}
